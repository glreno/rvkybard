        .TITLE      PM Graphics Overlay Color Picker
;
; All this thing does is boot up,
; load a custom display list and font and some PM graphics,
; and then hang.
;
; To load into MAC65: ENTER #D:PMO.LST,A
;
        .PAGE       SETUP
        .OPT OBJ
DEBUGMODE = 1
; Pick one of: 0=Cassette
;              1=Disk
;              2=2KB Cartridge
;              4=4KB Cartridge
;              8=8KB Cartridge
; (this is Line 200)
TARGET  = 8
;
; Where the assembled code goes!
        .IF TARGET = 8
STARTAP =   $A000 ; 8K left cartridge
        .ENDIF
        .IF TARGET = 4
STARTAP =   $B000 ; 4K left cartridge
        .ENDIF
        .IF TARGET = 2
STARTAP =   $B800 ; 2K left cartridge
        .ENDIF
        .IF TARGET = 2 .OR TARGET = 4 .OR TARGET = 8 ; any size cartridge
CARTINI =   $BFF9 ; end of left cartridge
STARTDL =   $B800
STARTPM =   $B800 ; 2K before end of cart
SCREEN  =   $0800 ; who needs DOS
        .ENDIF
;
        .IF TARGET = 1 ; disk
; disk start vector ; this is line 400
STARTAP =   $2800 ; just above memlo after DOS loads
RUNAD   = $02E0
        *= RUNAD
        .WORD STARTUP
        .ENDIF

        .IF TARGET = 0 ; cassette
STARTAP =   $0700 ; 
CASINI  = $02
        *= CASINI
        .WORD STARTUP
        .ENDIF

; MEMORY MAP (for cartridge)
; 0800 screen RAM - 960 bytes
; A000 application
; B400 font - 1K
; B800 display list (it's small, 32 bytes)
; B800 PMBASE - 1K with 384 unused bytes at the start
FONT    = $B400

        .PAGE       Addresses
;
; OS address constants
;
BLKBDV  =   $E471
NOCLIK  =   $02DB ; alas, XL only
PMBASE  =   $D407
GRACTL  =   $D01D
SDMCTL  =   $022F
GPRIOR  =   $026F
HPOSP0  =   $D000
HPOSP1  =   $D001
HPOSP2  =   $D002
HPOSP3  =   $D003
HPOSM0  =   $D004
HPOSM1  =   $D005
HPOSM2  =   $D006
HPOSM3  =   $D007
SIZEP0  =   $D008
SIZEP1  =   $D009
SIZEP2  =   $D00A
SIZEP3  =   $D00B
SIZEM   =   $D00C
CHBASE  =   $D409 ; location of font
PCOLR0  =   $02C0
PCOLR1  =   $02C1
PCOLR2  =   $02C2
PCOLR3  =   $02C3
COLOR0  =   $02C4
COLOR1  =   $02C5
COLOR2  =   $02C6
COLOR3  =   $02C7
COLOR4  =   $02C8
WSYNC   =   $D40A
VCOUNT  =   $D40B
VDLSTL  =   $0200 ; vector for display list interrupt
VDLSTH  =   $0201
SDLSTL  =   $0230 ; location of display list
SDLSTH  =   $0231
CHBAS   =   $02F4 ; location of font
SAVMSC  =   $0058 ; start of screen RAM
NMIEN   =   $D40E ; 0x80=DLI 0x40=VBI 0x20=RESET, default is 0x40
KEYBDV  =   $E420 ; Keyboard driver vectors
TMPL    =   $CC ; zero-page scratch location
TMPH    =   $CD ; zero-page scratch location
;
; Page 0 variables
; Simple multiplication routine
; Multiple $CE * $CF, store results in $CC,$CD
M2      = $CF
M1      = $CE
PRODL   = $CC
PRODH   = $CD
;
; Page 6 variables
DIGIT1  = $0600
DIGIT2  = $0601
;
;

        .PAGE       Some handy macros
;
; @LC -- load a constant byte into an address
        .MACRO @LC
            LDA # %1
            STA %2
        .ENDM
;
; Put %1 copies of %2 into a .BYTE op
; "@B 4,$FF" instead of ".BYTE $FF $FF $FF $FF"
        .MACRO @B
            .IF %1 > 0
                .BYTE %2
                @B %1-1,%2
            .ENDIF
        .ENDM
;
; Put a character on the screen at a const location:
; @PR x,y,char
;
        .MACRO @PR
            TYA
            PHA
            LDY # %2
            TXA
            PHA
            LDX # %1
            LDA # %3
            JSR PRXY
            PLA
            TAX
            PLA
            TAY
        .ENDM
;
; Print the number in A in hex at a constant location
; X and Y will be unchanged
; @PRN x,y
;
        .MACRO @PRN
            STA M1
            TYA
            PHA
            LDY # %2
            TXA
            PHA
            LDX # %1
            LDA M1
            JSR PRNXY
            PLA
            TAX
            PLA
            TAY
        .ENDM
;
;
;
        .PAGE       Application Startup
        *=  STARTAP
STARTUP ; @LC 1,NOCLIK ; Uncomment to turn of key click
;
;
;
; Set up display list and screen RAM
CR_DL   @LC 0,SDMCTL    ; turn off ANTIC while updating dlist
        LDA #>STARTDL
        STA SDLSTH
        LDA #<STARTDL
        STA SDLSTL
        LDA #>FONT
        STA CHBAS ; shadow register for font
EN_DL   LDA #<DLI
        STA VDLSTL
        LDA #>DLI
        STA VDLSTH
EN_PM   LDA #>STARTPM
        STA PMBASE
        @LC 3,GRACTL
        @LC 1,GPRIOR
        ; after dlist and pm are set up, enable Interrupts and ANTIC
        LDA #$C0
        STA NMIEN
        @LC $2E,SDMCTL  ; 2(norm playfield)+4(missiles)+8(players)+32(enable ANTIC)

; Load the screen
        @PR 0,0,$10 ; X,Y,C
        @PR 39,0,$11
        @PR 40,0,$12
        @PR 0,23,$13
        @PR 0,20,$13
        @PR 39,20,$14
        LDA COLOR0
        @PRN 3,21
        LDA COLOR1
        @PRN 6,21
        LDA COLOR2
        @PRN 9,21
        LDA COLOR3
        @PRN 12,21
        LDA COLOR4
        @PRN 15,21
        LDX #3
        LDY #15
        LDA COLOR0
        JSR PRNXY
        INY
        LDA COLOR1
        JSR PRNXY
        INY
        LDA COLOR2
        JSR PRNXY
        INY
        LDA COLOR3
        JSR PRNXY
        INY
        LDA COLOR4
        JSR PRNXY
; Hello
        @PR 8,2,CHAR_H
        @PR 9,2,CHAR_E
        @PR 10,2,CHAR_L
        @PR 11,2,CHAR_L
        @PR 12,2,CHAR_O
;
; Plot all 128 characters, twice.
;        LDX #127
;LOOP1   LDY #4
;        TXA
;        JSR PRXY
;        ORA #$80
;        LDY #8
;        JSR PRXY
;        DEX
;        BNE LOOP1
;
FOREVER
        ;
        ; Read two keys, then store result in PF2
        ;
        ; Read first digit, store in DIGIT1 and display at 30,22
        JSR DOKGETCH
        JSR ASCIITONYBBLE
        STA DIGIT1
        JSR GETCHARCODE
        LDY #22
        LDX #30
        JSR PRXY
        ; Read second digit, store in DIGIT2 and display at 30,23
        JSR DOKGETCH
        JSR ASCIITONYBBLE
        STA DIGIT2
        JSR GETCHARCODE
        LDY #22
        LDX #31
        JSR PRXY
        ; Turn them in to an actual number
        LDA DIGIT1
        ASL A
        ASL A
        ASL A
        ASL A
        ORA DIGIT2
        STA COLOR2
        JMP FOREVER
        .IF DEBUGMODE = 1
              ;0123456789ABCDEF
        .BYTE "XXX End of app X"
        .ENDIF
;
; Call KGETCH or KGB -- get a character from keyboard, return it in A
; This returns the ATASCII value; 0x30 is '0', 0x41 is 'A' 0x61 is 'a'
;                        Inverse: 0xB1         0xC1        0xE1
;
        .IF DEBUGMODE = 1
        *= $A600
              ;0123456789ABCDEF
        .BYTE "XXX DOKGETCH XXX"
        .ENDIF
DOKGETCH
.LOCAL
        LDA KEYBDV+5;   (high byte of KGETCH or KGB)
        PHA
        LDA KEYBDV+4;   (high byte of KGETCH or KGB)
        PHA
        RTS ; Simulate JMP (KGETCH or KGB)
        ; The keyboard driver will return to whoever did JSR DOKGETCH
;
;
;
; Converts an ASCII character to the equivalent HEX digit.
; Ignores case and the 0x80 Inverse flag.
; Anything else returns 0
; Ascii digits run from 0x30(0) to 0x39(9) ... 0x30 = 0011 0000
; Ascii lettrs run from 0x41(A) to 0x46(F) ... 0x40 = 0100 0000
; Lowercase    run from 0x61(A) to 0x66(F) ... 0x60 = 0110 0000
; ASCIITONYBBLE
        .IF DEBUGMODE = 1
        *= $A700
              ;0123456789ABCDEF
        .BYTE "X ASCIITONYBBLE "
        .ENDIF
ASCIITONYBBLE
.LOCAL
        ; get that pesky INVERSE bit out of the way
        AND #$7F
        STA M1 ; stash it in M1
        ; eliminate everything under 30
        SEC
        SBC #$30
        BMI ?RTZERO
        ; Check for numbers; they should be 0-9 now!
        CMP #10
        BMI ?RTNUM
        ; Make sure it's not a weird punctuation mark between 9 and A
        LDA M1
        SEC
        SBC #$41
        BMI ?RTZERO
        ; It's probably a letter. Get rid of the high bits.
        LDA M1
        AND #$1F
        ; Make sure it's below G
        CMP #7
        BMI ?RTLET
        ; Give up and return zero
?RTZERO LDA #0
        RTS
?RTNUM  LDA M1
        SEC
        SBC #$30
        RTS
?RTLET  ADC #9 ; it's a letter, and if acc has '1' that means 'A'
        RTS
;
;
; Look up internal character code for a given hex digit in A
; GETCHARCODE
        .IF DEBUGMODE = 1
        *= $A800
              ;0123456789ABCDEF
        .BYTE "XX GETCHARCODE X"
        .ENDIF
GETCHARCODE
.LOCAL
        STX M1
        TAX
        LDA HEXMAP,X
        LDX M1
        RTS
;
;
;
; Simple multiplication routine
; snarfed from "The Atari Assembler" p. 218 and 222
; Multiple $CE * $CF, store results in $CC,$CD   (my page zero addrs)
; Multiple 1102*1103, store results in 1100,1101 (orig addrs in book)
        .IF DEBUGMODE = 1
        *= $A900
              ;0123456789ABCDEF
        .BYTE "XX  MULTIPLY  XX"
        .ENDIF
;M2      = $CF ; 1103
;M1      = $CE ; 1102
;PRODL   = $CC ; 1101
;PRODH   = $CD ; 1100
MULTIPLY
.LOCAL
        TXA
        PHA
        LDX #8
        LDA #0
        STA PRODL
        STA PRODH
?MULTLP ASL A
        ROL PRODH
        ASL M2
        BCC ?MULTSK
        CLC
        ADC M1
        BCC ?MULTSK
        INC PRODH
?MULTSK DEX
        BNE ?MULTLP
        STA PRODL
        PLA
        TAX
        RTS
;
; Put character in A on the screen at location in X,Y registers
; Overwrites the Y register; X and A will be unchanged
; PRXY
;
        .IF DEBUGMODE = 1
        *= $AA00
              ;0123456789ABCDEF
        .BYTE "XXX   PRXY   XXX"
        .ENDIF
PRXY
.LOCAL
        ; Start with Y coord times 40
        ; Max Y is 24; 40*24=960 ($3C0) so need to carry
        ; 40 = 32 + 8; ASL 5 + ASL 3
        PHA ; stash the byte to print
        STY M1
        LDA #40
        STA M2
        JSR MULTIPLY
        ; Max X is 40, so just shove it into Y
        ; (I mean, it will WORK with X>40, but it will go on the next line)
        TXA
        TAY
        ; add screen base address
        LDA PRODH
        ADC # >SCREEN
        STA PRODH
        ; store stashed byte at that location
        PLA
        STA (PRODL),Y ; good thing PRODL is in Page 0
        RTS
;
; Print the number in A in hex at location in X,Y registers
; Stashes & restores X and Y
; PRNXY
;
        .IF DEBUGMODE = 1
        *= $AB00
              ;0123456789ABCDEF
        .BYTE "XXXX  PRNXY XXXX"
        .ENDIF
PRNXY
.LOCAL
        ; Stash X, Y and A
        STA M1
        TXA
        PHA     ; Stack: X
        TYA
        PHA     ; Stack: X Y
        PHA     ; Stack: X Y Y
        LDA M1
        PHA     ; Stack: X Y Y A
        ; grab the high nybble of A
        AND #$F0
        ROR A
        ROR A
        ROR A
        ROR A
        ; Look up char code
        JSR GETCHARCODE
        JSR PRXY
        ; increment X, grab the low nybble of A
        INX
        PLA     ; StackL X Y Y -> A
        STA M1
        PLA     ; StackL X Y -> Y A
        TAY
        LDA M1
        AND #$0F
        JSR GETCHARCODE
        JSR PRXY
        ; Restore X, Y
        PLA
        TAY
        PLA
        TAX
        RTS
;
;
; END OF FUNCTIONS
.LOCAL
;
;
;
        .IF DEBUGMODE = 1
        *= FONT-16
              ;0123456789ABCDEF
        .BYTE "XXXXX FONT XXXXX"
        .ENDIF
        .PAGE       Font at B400
        *= FONT
        ; Char 00 ASCII 32 (space)
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $01 ASCII 33 !    Color 01 block
        .BYTE $55,$55,$55,$55, $55,$55,$55,$55 ; 0101 0101 = $55
        ; Char $02 ASCII 34 "    Color 10 block
        .BYTE $AA,$AA,$AA,$AA, $AA,$AA,$AA,$AA ; 1010 1010 = $AA
        ; Char $03 ASCII 35 #    Color 11 block
        .BYTE $FF,$FF,$FF,$FF, $FF,$FF,$FF,$FF ; 1111 1111 = $FF
        ; Char $04 ASCII 36 $
        .BYTE $30,$FC,$C0,$FC, $0C,$FC,$30,0
        ; Char $05 ASCII 37 %
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $06 ASCII 38 &
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $07 ASCII 39 '
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $08 ASCII 40 (
        .BYTE 0,$30,$C0,$C0, $C0,$C0,$30,0
        ; Char $09 ASCII 41 )
        .BYTE 0,$30,$0C,$0C, $0C,$0C,$30,0
        ; Char $0A ASCII 42 *
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $0B ASCII 43 +
        .BYTE 0,0,$30,$FC, $30,0,0,0
        ; Char $0C ASCII 44 ,
        ; Char $0D ASCII 45 -
        ; Char $0E ASCII 46 .
        ; Char $0F ASCII 47 /
        ;
        *= FONT + 8*$10
        ; Font block 16 -- numbers
        ; All numbers are drawn as 3x7 using color 3
        ;
        ; Char $10 ASCII 48 Digit zero
        .BYTE $FC,$CC,$CC,$CC, $CC,$CC,$FC,0 ; 11001100 = $CC
        ; Char $11 ASCII 49 Digit one
        .BYTE $30,$30,$30,$30, $30,$30,$30,0 ; 00110000 = $30
        ; Char $12 ASCII 50 Digit two
        .BYTE $FC,$0C,$0C, $FC,$C0,$C0,$FC,0 ; 11111100 = $FC
        ; Char $13 ASCII 51 Digit three
        .BYTE $FC,$0C,$0C,$FC, $0C,$0C,$FC,0 ;
        ; Char $14 ASCII 52 Digit four
        .BYTE $CC,$CC,$CC,$FC, $0C,$0C,$0C,0 ;
        ; Char $15 ASCII 53 Digit five
        .BYTE $FC,$C0,$C0,$FC, $0C,$0C,$FC,0 ;
        ; Char $16 ASCII 54 Digit six
        .BYTE $FC,$C0,$C0,$FC, $CC,$CC,$FC,0 ;
        ; Char $17 ASCII 55 Digit seven
        .BYTE $FC,$0C,$0C,$0C, $30,$30,$30,0 ;
        ; Char $18 ASCII 56 Digit eight
        .BYTE $FC,$CC,$CC,$FC, $CC,$CC,$FC,0 ;
        ; Char $19 ASCII 57 Digit nine
        .BYTE $FC,$CC,$CC,$FC, $0C,$0C,$0C,0 ;
        ; Char $1A ASCII 58 :
        .BYTE 0,0,0,$30, 0,$30,0,0
        ; Char $1B ASCII 59 ;
        .BYTE 0,0,0,$30, 0,$30,$C0,0
        ; Char $1C ASCII 60 <
        .BYTE 0,0,$0C,$30, $C0,$30,$0C,0
        ; Char $1D ASCII 61 =
        .BYTE 0,0,$FC,0, 0,$FC,0,0
        ; Char $1E ASCII 62 >
        .BYTE 0,0,$C0,$30, $0C,$30,$C0,0
        ; Char $1F ASCII 63 ?
        .BYTE 0,$FC,$0C,$3C, $30,0,$30,0
        ;
        ; Font block 32 -- letters
        ; This is sparse, but I'll copy A-F anyway
        ;
        ; Char $20 ASCII 64 @
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $21 ASCII 65 A
        .BYTE $FC,$CC,$CC,$FC, $CC,$CC,$CC,0 ;
        ; Char $22 ASCII 66 B
        .BYTE $F0,$CC,$CC,$F0, $CC,$CC,$F0,0 ;
        ; Char $23 ASCII 67 C
        .BYTE $3C,$C0,$C0,$C0, $C0,$C0,$3C,0 ;
        ; Char $24 ASCII 68 D
        .BYTE $F0,$CC,$CC,$CC, $CC,$CC,$F0,0 ;
CHAR_E = $25 ; Char $25 ASCII 69 E
        .BYTE $FC,$C0,$C0,$FC, $C0,$C0,$FC,0 ;
CHAR_F = $26 ; Char $26 ASCII 70 F
        .BYTE $FC,$C0,$C0,$FC, $C0,$C0,$C0,0 ;
        ; Char $27 ASCII 71 G
        .BYTE 0,0,0,0, 0,0,0,0
CHAR_H = $28; ; Char $28 ASCII 72 H
        .BYTE $CC,$CC,$CC,$FC, $CC,$CC,$CC,0
        ; Char $29 ASCII 73 I
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $2A ASCII 74 J
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $2B ASCII 75 K
        .BYTE 0,0,0,0, 0,0,0,0
CHAR_L = $2C ; Char $2C ASCII 76 L
        .BYTE $C0,$C0,$C0,$C0, $C0,$C0,$FC,0
        ; Char $2D ASCII 77 M
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $2E ASCII 78 N
        .BYTE 0,0,0,0, 0,0,0,0
CHAR_O = $2F ; Char $2F ASCII 79 O
        .BYTE $30,$CC,$CC,$CC, $CC,$CC,$30,0
CHAR_P = $30 ; Char $30 ASCII 80 O
        .BYTE $F0,$CC,$CC,$F0, $C0,$C0,$C0,0

;
;
;

        .PAGE       Display list and PMbase at B800
        *= STARTDL
        .BYTE $70,$70,$70
        .BYTE $44
        .WORD SCREEN
        @B 10,4
        @B 9,4
        .BYTE $84 ; three lines for E:, interrupt first
        .BYTE 2
        .BYTE 2
        .BYTE 2
        .BYTE $41
        .WORD STARTDL
; and now the interrupt
DLI     PHA ; always save the accumulator!
        LDA #$28
        STA $D016 ; COLPF0 hardware register
        LDA #$94
        STA $D018 ; COLPF2 hardware register
        LDA #$E0 ; Atari ROM character set
        STA $D409 ; CHBASE hardware register; shadow is $2F4 CHBAS
        PLA
        RTI
;
; Map of what internal char code goes with which hex digit
HEXMAP  .BYTE $10,$11,$12,$13, $14,$15,$16,$17
        .BYTE $18,$19,$21,$22, $23,$24,$25,$26
        .PAGE       Cartridge Trailer
        .IF TARGET = 2 .OR TARGET = 4 .OR TARGET = 8 ; any size cartridge
        .IF DEBUGMODE = 1
        *=  CARTINI - 32
        .BYTE 0,0,0,"Cartridge Header",0,0,0
        .ENDIF
        *=  CARTINI
        ; Cart init code goes here -- usually nothing at all!
        RTS ; end of cart initialization
        .WORD STARTUP ; where to JMP after cart and OS are initted
        .BYTE 0     ; just a zero
        .BYTE 4     ; boot opt - no disk
        .WORD CARTINI
        .ENDIF
        .END
