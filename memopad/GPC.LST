        .TITLE      PM Graphics Overlay Color Picker
;
; All this thing does is boot up,
; load a custom display list and font and some PM graphics,
; and then hang.
;
; To load into MAC65: ENTER #D:GPC.LST,A
;
        .PAGE       SETUP
        .OPT OBJ
DEBUGMODE = 1
; Pick one of: 0=Cassette
;              1=Disk
;              2=2KB Cartridge
;              4=4KB Cartridge
;              8=8KB Cartridge
; (this is Line 200)
TARGET  = 8
;
; Where the assembled code goes!
        .IF TARGET = 8
STARTAP =   $A000 ; 8K left cartridge
        .ENDIF
        .IF TARGET = 4
STARTAP =   $B000 ; 4K left cartridge
        .ENDIF
        .IF TARGET = 2
STARTAP =   $B800 ; 2K left cartridge
        .ENDIF
        .IF TARGET = 2 .OR TARGET = 4 .OR TARGET = 8 ; any size cartridge
CARTINI =   $BFF9 ; end of left cartridge
STARTDL =   $B800
STARTPM =   $B800 ; 2K before end of cart
SCREEN  =   $0800 ; who needs DOS
        .ENDIF
;
        .IF TARGET = 1 ; disk
; disk start vector ; this is line 400
STARTAP =   $2800 ; just above memlo after DOS loads
RUNAD   = $02E0
        *= RUNAD
        .WORD STARTUP
        .ENDIF

        .IF TARGET = 0 ; cassette
STARTAP =   $0700 ;
CASINI  = $02
        *= CASINI
        .WORD STARTUP
        .ENDIF

; MEMORY MAP (for cartridge)
; 0800 screen RAM - 960 bytes
; A000 application
; B400 font - 1K
; B800 display list (it's small, 32 bytes)
; B800 PMBASE - 1K with 384 unused bytes at the start
FONT    = $B400

        .PAGE       Addresses
;
; OS address constants
;
BLKBDV  =   $E471
NOCLIK  =   $02DB ; alas, XL only
PMBASE  =   $D407
GRACTL  =   $D01D
SDMCTL  =   $022F
GPRIOR  =   $026F
HPOSP0  =   $D000
HPOSP1  =   $D001
HPOSP2  =   $D002
HPOSP3  =   $D003
HPOSM0  =   $D004
HPOSM1  =   $D005
HPOSM2  =   $D006
HPOSM3  =   $D007
SIZEP0  =   $D008
SIZEP1  =   $D009
SIZEP2  =   $D00A
SIZEP3  =   $D00B
SIZEM   =   $D00C
CHBASE  =   $D409 ; location of font
PCOLR0  =   $02C0
PCOLR1  =   $02C1
PCOLR2  =   $02C2
PCOLR3  =   $02C3
COLOR0  =   $02C4
COLOR1  =   $02C5
COLOR2  =   $02C6
COLOR3  =   $02C7
COLOR4  =   $02C8
WSYNC   =   $D40A
VCOUNT  =   $D40B
VDLSTL  =   $0200 ; vector for display list interrupt
VDLSTH  =   $0201
SDLSTL  =   $0230 ; location of display list
SDLSTH  =   $0231
CHBAS   =   $02F4 ; location of font
SAVMSC  =   $0058 ; start of screen RAM
NMIEN   =   $D40E ; 0x80=DLI 0x40=VBI 0x20=RESET, default is 0x40
KEYBDV  =   $E420 ; Keyboard driver vectors

INVMASK = $80
LABELY  = 23
EDITY   = 22
;
; Page 0 variables
; Simple multiplication routine
; Multiple $CE * $CF, store results in $CC,$CD
M2      = $CF
M1      = $CE
PRODL   = $CC
PRODH   = $CD
; Loop var for PRINT
PL      = $D0
PH      = $D1
;
; Page 6 variables
; chars in the current editor
DIGIT1  = $0600
DIGIT2  = $0601
; index of color being printed, based on PCOLR0 $2C0
; so 0=P0 1=P1 2=P2 3=P3 4=PF0 5=PF1 6=PF2 7=PF3 8=PF4
; this is also the location on the screen to update, kinda.
; In the viewer, the plain colors are at Y=COLRIDX
; In the editor, the hex values are at X=COLRIDX*4
COLRIDX = $0602
; index of the color being edited
EDITIDX = $0603
; Set to $80 to invert all the text in the display
INVERT  = $0604
INVERT2 = $0605
; Y param for the PRINT routine
P_Y     = $0606

        .PAGE       Some handy macros
;
; @LC -- load a constant byte into an address
        .MACRO @LC
            LDA # %1
            STA %2
        .ENDM
;
;
; Put 4 copies of %1 into a .BYTE op
; "@B4 #FF" instead of @B 4,$FF" instead of ".BYTE $FF $FF $FF $FF"
        .MACRO @B4
            .BYTE %1,%1,%1,%1
        .ENDM
        .MACRO @B4__00
            *= *+4
        .ENDM
;
; Print a string located at %2 at coords 0,%1
; Uses PRXY, so the char will be inverted if INVERT is set
; Local variable: PL,PH in page zero and P_Y
        .MACRO @PRINT
            LDA # <%2
            STA PL
            LDA # >%2
            STA PH
            LDA # %1
            STA P_Y
            JSR PRINT
        .ENDM
;
;
        .PAGE       Application Startup
        *=  STARTAP
STARTUP ; @LC 1,NOCLIK ; Uncomment to turn of key click
;
;
;
; Set up display list and screen RAM
CR_DL   @LC 0,SDMCTL    ; turn off ANTIC while updating dlist
        LDA #>STARTDL
        STA SDLSTH
        LDA #<STARTDL
        STA SDLSTL
        LDA #>FONT
        STA CHBAS ; shadow register for font
EN_DL   LDA #<DLI
        STA VDLSTL
        LDA #>DLI
        STA VDLSTH
EN_PM   LDA #>STARTPM
        STA PMBASE
        @LC 3,GRACTL
        @LC 32,GPRIOR
        ; after dlist and pm are set up, enable Interrupts and ANTIC
        LDA #$C0
        STA NMIEN
        @LC $2E,SDMCTL  ; 2(norm playfield)+4(missiles)+8(players)+32(enable ANTIC)
        ; position the Players
        LDA #92
        STA HPOSP0
        STA HPOSP1
        STA HPOSP2
        STA HPOSP3
        LDA #3
        STA SIZEP0
        STA SIZEP1
        STA SIZEP2
        STA SIZEP3
        ; initial colors, chosen to show overlaps. The Players are grey.
        @LC $02,PCOLR0
        @LC $04,PCOLR1
        @LC $06,PCOLR2
        @LC $08,PCOLR3
        ; the playfields are all intensity 4 except BAK
        @LC $14,COLOR0
        @LC $24,COLOR1
        @LC $44,COLOR2
        @LC $84,COLOR3
        @LC $00,COLOR4


; Main program. There are four basic parts:
; 1. LDSSCR Load the static screen
; 1.A. Load the static Players
; 1.B. Load the static text
; 2. LDDSCR Update the dynamic screen
; 2.A. Load the updated text fields in the Editor pane
; 2.B. Load the updated register values all over the dynamic screen
; 2.C. Load the calculated fields in the dynamic screen
; (1 is done once, 2 will need to be done over and over again)
; 3. EDIT Edit a field
; 3.A. Set cursor in the current active text field
; 3.B. Accept two characters of input (or a tab to skip - 2A will undo changes)
; 3.C. Update the current active color shadow register
; 3.D. Increment to the next field and color register
; 4. DONE Loop back to 2.A.
;

; Load the screen
        @LC 0,INVERT
        LDA #4 ; start editing with PF0
        STA EDITIDX
LDSSCR  ; Load the static screen
        ; print 20 lines
        @PRINT 0,R00S
        @PRINT 1,R01S
        @PRINT 2,R02S
        @PRINT 3,R03S
        @PRINT 4,R04S
        @PRINT 5,R05S
        @PRINT 6,R06S
        @PRINT 7,R07S
        @PRINT 8,R08S
        @PRINT 9,R09S
        @PRINT 10,R10S
        @PRINT 11,R11S
        @PRINT 12,R12S
        @PRINT 13,R13S
        @PRINT 14,R14S
        @PRINT 15,R15S
        @PRINT 16,R16S
        @PRINT 17,R17S
        @PRINT 18,R18S
        @PRINT 19,R19S
        @PRINT 20,R20S
        @PRINT 21,R21S
        @PRINT 23,R23S ; editor labels
        ; now 20 equal signs
        LDA #20
        STA P_Y
        LDX #25
        LDA #$1D
EQLOOP  LDY P_Y
        JSR PRXY
        DEC P_Y
        BPL EQLOOP
        
FOREVER
LDDSCR  ; Load the dynamic screen
; In the viewer, the plain colors are at Y=COLRIDX
; In the editor, the hex values are at X=COLRIDX*4
        LDA #8
        STA COLRIDX
DSCRLOOP
;       LDY COLRIDX
;       LDX #7
;       LDA PCOLR0,Y
;       JSR PRNXY

        ; load color value into editor
        LDA COLRIDX
        ASL A
        ASL A
        ADC #1
        TAX
        LDY COLRIDX
        LDA PCOLR0,Y
        LDY #EDITY
        JSR PRNXY

        DEC COLRIDX
        BPL DSCRLOOP

        JSR R00D
        JSR R01D
        JSR R02D
        JSR R03D
        JSR R04D
        JSR R05D
        JSR R06D
        JSR R07D
        JSR R08D
        JSR R09D
        JSR R10D
        JSR R11D
        JSR R12D
        JSR R13D
        JSR R14D
        JSR R15D
        JSR R16D
        JSR R17D
        JSR R18D
        JSR R19D
        JSR R20D
        JSR R21D

        ; update the editor's 'invert' value
        LDX #38
        LDY #EDITY
        LDA #CHAR_0
        PHA
        LDA INVERT
        CMP #INVMASK
        BNE NOINV
        PLA
        LDA #CHAR_1
        PHA
NOINV   PLA
        JSR PRXY
EDIT
        LDA EDITIDX
        CMP #9
        BNE GETD1
        LDA #0
        STA EDITIDX
        ; Field 9 (at 38,22) is a 0/1 field for setting the invert flag
        LDA #0
        PHA
        LDX #38
        LDY #EDITY
        JSR INVERTXY
        JSR DOKGETCH
        ; check for tab: (discard changes and sckip to next field)
        CMP #127
        BEQ NOSETINV
        CMP #49 ; "1" to set invert mode
        BNE SETINV
        LDA #INVMASK
        PHA
SETINV  PLA
        STA INVERT
        ; instead of jumping to DONE or FOREVER do a full refresh
        JMP LDSSCR
NOSETINV
        PLA
        JMP LDSSCR

        ;
        ; Read two keys, then store result in PF2
        ;
        ; Read first digit, store in DIGIT1 and display at 30,22
GETD1   LDA EDITIDX
        ASL A
        ASL A
        ADC #1
        TAX
        LDY #EDITY
        JSR INVERTXY

        STX M1
        JSR DOKGETCH
        LDX M1
        LDY #EDITY
        JSR INVERTXY
        ; check for tab: (discard changes and sckip to next field)
        CMP #127
        BEQ N2 ; NEXTIDX is too far away!
        CMP #126 ; backspace not allowed
        BEQ GETD1
        CMP #155 ; enter not allowed
        BEQ GETD1
STORED1 JSR ASCIITONYBBLE
        STA DIGIT1

        LDA EDITIDX
        ASL A
        ASL A
        ADC #1
        TAX
        LDA DIGIT1
        JSR GETCHARCODE
        LDY #EDITY
        JSR PRXY

        ; Read second digit, store in DIGIT2 and display at 30,23
GETD2   LDA EDITIDX
        ASL A
        ASL A
        ADC #2
        TAX
        LDY #EDITY
        JSR INVERTXY

        STX M1
        JSR DOKGETCH
        LDX M1
        LDY #EDITY
        JSR INVERTXY
        ; check for tab: (discard changes and sckip to next field)
        CMP #127
        BEQ NEXTIDX
        CMP #155 ; enter not allowed
        BEQ GETD2
        ; check for backspace (go back one digit)
        CMP #126
        BNE STORED2
        ;DEC EDITIDX
        JMP GETD1
        ; store it
STORED2 JSR ASCIITONYBBLE
        STA DIGIT2

        LDA EDITIDX
        ASL A
        ASL A
        ADC #2
        TAX
        LDA DIGIT2
        JSR GETCHARCODE
        LDY #EDITY
        JSR PRXY

        ; Wait for return
WAITCR  INX
        LDY #EDITY
        JSR INVERTXY
        STX M1
        JSR DOKGETCH
        LDX M1
        LDY #EDITY
        JSR INVERTXY
        ; Return: 155 = $9B
        CMP #155
        BEQ ACCEPT
        ; Tab: 127 $7F
        CMP #127
N2      BEQ NEXTIDX

        ; Backspace: 127 $7E
        CMP #126
        BNE WAITCR
        ;DEC EDITIDX
        JMP GETD2

        ; Turn them in to an actual number
ACCEPT  LDA DIGIT1
        ASL A
        ASL A
        ASL A
        ASL A
        ORA DIGIT2
        LDY EDITIDX
        STA PCOLR0,Y

        ; Done editing that color
NEXTIDX INC EDITIDX

DONE    JMP FOREVER
        .IF DEBUGMODE = 1
              ;0123456789ABCDEF
        .BYTE "XXX End of app X"
        .ENDIF
;
; Call KGETCH or KGB -- get a character from keyboard, return it in A
; This returns the ATASCII value; 0x30 is '0', 0x41 is 'A' 0x61 is 'a'
;                        Inverse: 0xB1         0xC1        0xE1
;
        .IF DEBUGMODE = 1
        *= $A600
              ;0123456789ABCDEF
        .BYTE "XXX DOKGETCH XXX"
        .ENDIF
DOKGETCH
.LOCAL
        LDA KEYBDV+5;   (high byte of KGETCH or KGB)
        PHA
        LDA KEYBDV+4;   (high byte of KGETCH or KGB)
        PHA
        RTS ; Simulate JMP (KGETCH or KGB)
        ; The keyboard driver will return to whoever did JSR DOKGETCH
;
;
;
; Converts an ASCII character to the equivalent HEX digit.
; Ignores case and the 0x80 Inverse flag.
; Anything else returns 0
; Ascii digits run from 0x30(0) to 0x39(9) ... 0x30 = 0011 0000
; Ascii lettrs run from 0x41(A) to 0x46(F) ... 0x40 = 0100 0000
; Lowercase    run from 0x61(A) to 0x66(F) ... 0x60 = 0110 0000
; ASCIITONYBBLE
        .IF DEBUGMODE = 1
        *= $A700
              ;0123456789ABCDEF
        .BYTE "X ASCIITONYBBLE "
        .ENDIF
ASCIITONYBBLE
.LOCAL
        ; get that pesky INVERSE bit out of the way
        AND #$7F
        STA M1 ; stash it in M1
        ; eliminate everything under 30
        SEC
        SBC #$30
        BMI ?RTZERO
        ; Check for numbers; they should be 0-9 now!
        CMP #10
        BMI ?RTNUM
        ; Make sure it's not a weird punctuation mark between 9 and A
        LDA M1
        SEC
        SBC #$41
        BMI ?RTZERO
        ; It's probably a letter. Get rid of the high bits.
        LDA M1
        AND #$1F
        ; Make sure it's below G
        CMP #7
        BMI ?RTLET
        ; Give up and return zero
?RTZERO LDA #0
        RTS
?RTNUM  LDA M1
        SEC
        SBC #$30
        RTS
?RTLET  ADC #9 ; it's a letter, and if acc has '1' that means 'A'
        RTS
;
;
; Look up internal character code for a given hex digit in A
; GETCHARCODE
        .IF DEBUGMODE = 1
        *= $A800
              ;0123456789ABCDEF
        .BYTE "XX GETCHARCODE X"
        .ENDIF
GETCHARCODE
.LOCAL
        STX M1
        TAX
        LDA HEXMAP,X
        LDX M1
        RTS
;
;
;
; Simple multiplication routine
; snarfed from "The Atari Assembler" p. 218 and 222
; Multiple $CE * $CF, store results in $CC,$CD   (my page zero addrs)
; Multiple 1102*1103, store results in 1100,1101 (orig addrs in book)
        .IF DEBUGMODE = 1
        *= $A900
              ;0123456789ABCDEF
        .BYTE "XX  MULTIPLY  XX"
        .ENDIF
;M2      = $CF ; 1103
;M1      = $CE ; 1102
;PRODL   = $CC ; 1101
;PRODH   = $CD ; 1100
MULTIPLY
.LOCAL
        TXA
        PHA
        LDX #8
        LDA #0
        STA PRODL
        STA PRODH
?MULTLP ASL A
        ROL PRODH
        ASL M2
        BCC ?MULTSK
        CLC
        ADC M1
        BCC ?MULTSK
        INC PRODH
?MULTSK DEX
        BNE ?MULTLP
        STA PRODL
        PLA
        TAX
        RTS
;
; Put character in A on the screen at location in X,Y registers
; Overwrites the Y register; X and A will be unchanged
; PRXY
;
        .IF DEBUGMODE = 1
        *= $AA00
              ;0123456789ABCDEF
        .BYTE "XXX   PRXY   XXX"
        .ENDIF
PRXY
.LOCAL
        ; Start with Y coord times 40
        ; Max Y is 24; 40*24=960 ($3C0) so need to carry
        ; 40 = 32 + 8; ASL 5 + ASL 3
        PHA ; stash the byte to print
        STY M1
        LDA #40
        STA M2
        JSR MULTIPLY
        ; Max X is 40, so just shove it into Y
        ; (I mean, it will WORK with X>40, but it will go on the next line)
        TXA
        TAY
        ; add screen base address
        LDA PRODH
        ADC # >SCREEN
        STA PRODH
        ; store stashed byte at that location
        PLA
        EOR INVERT ; this will be either $80 or 0 -- and so invert the high bit
        STA (PRODL),Y ; good thing PRODL is in Page 0
        RTS
PRXYNOINV
        PHA
        PHA
        LDA INVERT
        STA INVERT2
        LDA #0
        STA INVERT
        PLA
        JSR PRXY
        LDA INVERT2
        STA INVERT
        PLA
        RTS
;
; Read character on screen at location in X,Y registers
; and invert it
; Overwrites the Y register; X and A will be unchanged
; INVERTXY
;
        .IF DEBUGMODE = 1
        *= $AA80
              ;0123456789ABCDEF
        .BYTE "XXX   INVERTXY   XXX"
        .ENDIF
INVERTXY
.LOCAL
        ; Start with Y coord times 40
        ; Max Y is 24; 40*24=960 ($3C0) so need to carry
        ; 40 = 32 + 8; ASL 5 + ASL 3
        PHA
        STY M1
        LDA #40
        STA M2
        JSR MULTIPLY
        ; Max X is 40, so just shove it into Y
        ; (I mean, it will WORK with X>40, but it will go on the next line)
        TXA
        TAY
        ; add screen base address
        LDA PRODH
        ADC # >SCREEN
        STA PRODH
        ; store stashed byte at that location
        LDA (PRODL),Y ; good thing PRODL is in Page 0
        EOR #$80
        STA (PRODL),Y ; good thing PRODL is in Page 0
        PLA
        RTS
;
; Print the number in A in hex at location in X,Y registers
; Stashes & restores X and Y
; PRNXY
;
        .IF DEBUGMODE = 1
        *= $AB00
              ;0123456789ABCDEF
        .BYTE "XXXX  PRNXY XXXX"
        .ENDIF
PRNXY
.LOCAL
        ; Stash X, Y and A
        STA M1
        TXA
        PHA     ; Stack: X
        TYA
        PHA     ; Stack: X Y
        PHA     ; Stack: X Y Y
        LDA M1
        PHA     ; Stack: X Y Y A
        ; grab the high nybble of A
        AND #$F0
        LSR A
        LSR A
        LSR A
        LSR A
        ; Look up char code
        JSR GETCHARCODE
        JSR PRXY
        ; increment X, grab the low nybble of A
        INX
        PLA     ; StackL X Y Y -> A
        STA M1
        PLA     ; StackL X Y -> Y A
        TAY
        LDA M1
        AND #$0F
        JSR GETCHARCODE
        JSR PRXY
        ; Restore X, Y
        PLA
        TAY
        PLA
        TAX
        RTS
;
; Print a string (addr in PL,PH) on line y=P_Y starting at x=0
; Uses PRXY, so the char will be inverted if INVERT is set
; PRXY maintains X,A but wipes out the Y register
;
; PRINT
.LOCAL
        .IF DEBUGMODE = 1
        *= $AC00
              ;0123456789ABCDEF
        .BYTE "XXXX PRINT  XXXX"
        .ENDIF
PRINT
        LDX #0
PLOOP   ; get the text value
        TXA
        TAY
        LDA (PL),Y
        BMI PDONE ; negative value means end of string
        ; get Y coord
        LDY P_Y
        JSR PRXY
        ; x++ and loop
        INX
        JMP PLOOP
PDONE   RTS
;
; END OF FUNCTIONS
.LOCAL
;
;
; Some constants
        .IF DEBUGMODE = 1
              ;0123456789ABCDEF
        .BYTE "XXX CONSTANTS XX"
        .ENDIF
; ascii codes for the single blocks of color for each PF.
COLORBLOCK .BYTE 1,2,3,131,0
;
;
    ; A row that contains only PF4, the background
    .MACRO @ROW_NO
        RTS
    .ENDM
    ; A row that contains only a PF color
    .MACRO @ROW_F
        ; Print color block in col 11 and 12
        LDA COLORBLOCK+%2
        LDX #11
        LDY # %1
        JSR PRXYNOINV
        LDX #12
        LDY # %1
        JSR PRXYNOINV
        ; Print PF value in col 16
        LDA COLOR0+%2
        LDX #16
        LDY # %1
        JSR PRNXY
        ; Print sum in col 27
        LDA COLOR0+%2
        LDX #27
        LDY # %1
        JSR PRNXY
        RTS
    .ENDM
    ; A row that contains a PF and a PM
    .MACRO @ROW_FP
        ; Print color block in col 11 and 12
        LDA COLORBLOCK+%2
        LDX #11
        LDY # %1
        JSR PRXYNOINV
        LDX #12
        LDY # %1
        JSR PRXYNOINV
        ; Print PF value in col 16
        LDA COLOR0+%2
        LDX #16
        LDY # %1
        JSR PRNXY
        ; Print PM value in col 19
        LDA PCOLR0+%3
        LDX #19
        LDY # %1
        JSR PRNXY
        ; Print sum in col 27
        LDA COLOR0+%2
        ORA PCOLR0+%3
        LDX #27
        LDY # %1
        JSR PRNXY
        RTS
    .ENDM
    ; A row that contains a PF and two PMs
    .MACRO @ROWFPP
        ; Print color block in col 11 and 12
        LDA COLORBLOCK+%2
        LDX #11
        LDY # %1
        JSR PRXYNOINV
        LDX #12
        LDY # %1
        JSR PRXYNOINV
        ; Print PF value in col 16
        LDA COLOR0+%2
        LDX #16
        LDY # %1
        JSR PRNXY
        ; Print PM-A value in col 19
        LDA PCOLR0+%3
        LDX #19
        LDY # %1
        JSR PRNXY
        ; Print PM-B value in col 22
        LDA PCOLR0+%4
        LDX #22
        LDY # %1
        JSR PRNXY
        ; Print sum in col 27
        LDA COLOR0+%2
        ORA PCOLR0+%3
        ORA PCOLR0+%4
        LDX #27
        LDY # %1
        JSR PRNXY
        RTS
    .ENDM
    ; A row that contains only a single PM color
    .MACRO @ROW_P
        ; Print PM value in col 19
        LDA PCOLR0+%2
        LDX #19
        LDY # %1
        JSR PRNXY
        ; Print sum in col 27
        LDA PCOLR0+%2
        LDX #27
        LDY # %1
        JSR PRNXY
        RTS
    .ENDM
    ; A row that contains two PM colors
    .MACRO @ROW_PP
        ; Print PM-A value in col 19
        LDA PCOLR0+%2
        LDX #19
        LDY # %1
        JSR PRNXY
        ; Print PM-B value in col 22
        LDA PCOLR0+%3
        LDX #22
        LDY # %1
        JSR PRNXY
        ; Print sum in col 27
        LDA PCOLR0+%2
        ORA PCOLR0+%3
        LDX #27
        LDY # %1
        JSR PRNXY
        RTS
    .ENDM
; The display layout! Each row is a string to print,
; (use .SBYTE to store the printable internal char codes)
; and a macro that does the dynamic display. Note
; that the macro ends in RTS!

;              PFx Py Pz xXyz xx yy zz = ss  1111 1111
;             01234567890123456789012345678901234567890
R00S    .SBYTE "    P0",-1
R01S    .SBYTE "    P1",-1
R02S    .SBYTE "    P2",-1
R03S    .SBYTE "    P3",-1
R04S    .SBYTE "PF0",-1
R05S    .SBYTE "PF1",-1
R06S    .SBYTE "PF2",-1
R07S    .SBYTE "PF3",-1
R08S    .SBYTE "PF4",-1
R09S    .SBYTE "    P0 P1",-1
R10S    .SBYTE "    P2 P3",-1
R11S    .SBYTE "PF0 P0",-1
R12S    .SBYTE "PF0 P1",-1
R13S    .SBYTE "PF0 P0 P1",-1
R14S    .SBYTE "PF1 P0",-1
R15S    .SBYTE "PF1 P1",-1
R16S    .SBYTE "PF1 P0 P1",-1
R17S    .SBYTE "PF4",-1
R18S    .SBYTE "PF4",-1
R19S    .SBYTE "PF4",-1
R20S    .SBYTE "PF4",-1
R21S    .SBYTE "PF1",-1
R23S    .SBYTE " P0  P1  P2  P3 PF0 PF1 PF2 PF3 PF4 INV",-1

R00D @ROW_P   0,0
R01D @ROW_P   1,1
R02D @ROW_P   2,2
R03D @ROW_P   3,3
R04D @ROW_F   4,0
R05D @ROW_F   5,1
R06D @ROW_F   6,2
R07D @ROW_F   7,3
R08D @ROW_F   8,4
R09D @ROW_PP  9,0,1
R10D @ROW_PP 10,2,3
R11D @ROW_FP 11,0,0
R12D @ROW_FP 12,0,1
R13D @ROWFPP 13,0,0,1
R14D @ROW_FP 14,1,0
R15D @ROW_FP 15,1,1
R16D @ROWFPP 16,1,0,1
R17D @ROW_NO 17
R18D @ROW_NO 18
R19D @ROW_NO 19
R20D @ROW_NO 20
R21D @ROW_F  21,1

;
;
;
        .IF DEBUGMODE = 1
        *= FONT-16
              ;0123456789ABCDEF
        .BYTE "XXXXX FONT XXXXX"
        .ENDIF
        .PAGE       Font at B400
        *= FONT
        ; Char 00 ASCII 32 (space)
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $01 ASCII 33 !    Color 01 block
        .BYTE $55,$55,$55,$55, $55,$55,$55,$55 ; 0101 0101 = $55
        ; Char $02 ASCII 34 "    Color 10 block
        .BYTE $AA,$AA,$AA,$AA, $AA,$AA,$AA,$AA ; 1010 1010 = $AA
        ; Char $03 ASCII 35 #    Color 11 block
        .BYTE $FF,$FF,$FF,$FF, $FF,$FF,$FF,$FF ; 1111 1111 = $FF
        ; Char $04 ASCII 36 $
        .BYTE $30,$FC,$C0,$FC, $0C,$FC,$30,0
        ; Char $05 ASCII 37 %
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $06 ASCII 38 &
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $07 ASCII 39 '
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $08 ASCII 40 (
        .BYTE 0,$30,$C0,$C0, $C0,$C0,$30,0
        ; Char $09 ASCII 41 )
        .BYTE 0,$30,$0C,$0C, $0C,$0C,$30,0
        ; Char $0A ASCII 42 *
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $0B ASCII 43 +
        .BYTE 0,0,$30,$FC, $30,0,0,0
        ; Char $0C ASCII 44 ,
        ; Char $0D ASCII 45 -
        ; Char $0E ASCII 46 .
        ; Char $0F ASCII 47 /
        ;
        *= FONT + 8*$10
        ; Font block 16 -- numbers
        ; All numbers are drawn as 3x7 using color 3
        ;
CHAR_0 = $10 ; Char $10 ASCII 48 Digit zero
        .BYTE $FC,$CC,$CC,$CC, $CC,$CC,$FC,0 ; 11001100 = $CC
CHAR_1 = $11 ; Char $11 ASCII 49 Digit one
        .BYTE $30,$30,$30,$30, $30,$30,$30,0 ; 00110000 = $30
        ; Char $12 ASCII 50 Digit two
        .BYTE $FC,$0C,$0C, $FC,$C0,$C0,$FC,0 ; 11111100 = $FC
        ; Char $13 ASCII 51 Digit three
        .BYTE $FC,$0C,$0C,$FC, $0C,$0C,$FC,0 ;
        ; Char $14 ASCII 52 Digit four
        .BYTE $CC,$CC,$CC,$FC, $0C,$0C,$0C,0 ;
        ; Char $15 ASCII 53 Digit five
        .BYTE $FC,$C0,$C0,$FC, $0C,$0C,$FC,0 ;
        ; Char $16 ASCII 54 Digit six
        .BYTE $FC,$C0,$C0,$FC, $CC,$CC,$FC,0 ;
        ; Char $17 ASCII 55 Digit seven
        .BYTE $FC,$0C,$0C,$0C, $30,$30,$30,0 ;
        ; Char $18 ASCII 56 Digit eight
        .BYTE $FC,$CC,$CC,$FC, $CC,$CC,$FC,0 ;
        ; Char $19 ASCII 57 Digit nine
        .BYTE $FC,$CC,$CC,$FC, $0C,$0C,$0C,0 ;
        ; Char $1A ASCII 58 :
        .BYTE 0,0,0,$30, 0,$30,0,0
        ; Char $1B ASCII 59 ;
        .BYTE 0,0,0,$30, 0,$30,$C0,0
        ; Char $1C ASCII 60 <
        .BYTE 0,0,$0C,$30, $C0,$30,$0C,0
        ; Char $1D ASCII 61 =
        .BYTE 0,0,$FC,0, 0,$FC,0,0
        ; Char $1E ASCII 62 >
        .BYTE 0,0,$C0,$30, $0C,$30,$C0,0
        ; Char $1F ASCII 63 ?
        .BYTE 0,$FC,$0C,$3C, $30,0,$30,0
        ;
        ; Font block 32 -- letters
        ; This is sparse, but I'll copy A-F anyway
        ;
        ; Char $20 ASCII 64 @
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $21 ASCII 65 A
        .BYTE $FC,$CC,$CC,$FC, $CC,$CC,$CC,0 ;
        ; Char $22 ASCII 66 B
        .BYTE $F0,$CC,$CC,$F0, $CC,$CC,$F0,0 ;
        ; Char $23 ASCII 67 C
        .BYTE $3C,$C0,$C0,$C0, $C0,$C0,$3C,0 ;
        ; Char $24 ASCII 68 D
        .BYTE $F0,$CC,$CC,$CC, $CC,$CC,$F0,0 ;
CHAR_E = $25 ; Char $25 ASCII 69 E
        .BYTE $FC,$C0,$C0,$FC, $C0,$C0,$FC,0 ;
CHAR_F = $26 ; Char $26 ASCII 70 F
        .BYTE $FC,$C0,$C0,$FC, $C0,$C0,$C0,0 ;
        ; Char $27 ASCII 71 G
        .BYTE 0,0,0,0, 0,0,0,0
CHAR_H = $28 ; Char $28 ASCII 72 H
        .BYTE $CC,$CC,$CC,$FC, $CC,$CC,$CC,0
CHAR_I = $29 ; Char $29 ASCII 73 I
        .BYTE $FC,$30,$30,$30, $30,$30,$FC,0
        ; Char $2A ASCII 74 J
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $2B ASCII 75 K
        .BYTE 0,0,0,0, 0,0,0,0
CHAR_L = $2C ; Char $2C ASCII 76 L
        .BYTE $C0,$C0,$C0,$C0, $C0,$C0,$FC,0
        ; Char $2D ASCII 77 M
        .BYTE 0,0,0,0, 0,0,0,0
CHAR_N = $2E ; Char $2E ASCII 78 N
        .BYTE 0,0,0,0, 0,0,0,0
CHAR_O = $2F ; Char $2F ASCII 79 O
        .BYTE $30,$CC,$CC,$CC, $CC,$CC,$30,0
CHAR_P = $30 ; Char $30 ASCII 80 P
        .BYTE $F0,$CC,$CC,$F0, $C0,$C0,$C0,0
CHAR_Q = $31 ; Char $31 ASCII 81 Q
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $32 ASCII 82 R
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $33 ASCII 83 S
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $34 ASCII 84 T
        .BYTE 0,0,0,0, 0,0,0,0
        ; Char $35 ASCII 85 U
        .BYTE 0,0,0,0, 0,0,0,0
CHAR_V = $36 ; Char $36 ASCII 86 V
        .BYTE 0,0,0,0, 0,0,0,0

;
;
;

        .PAGE       Display list and PMbase at B800
        *= STARTDL
        .BYTE $70,$70,$70
        .BYTE $44
        .WORD SCREEN
        .BYTE 4,4,4,4,4, 4,4,4,4,4
        .BYTE 4,4,4,4,4, 4,4,4,4,4
        .BYTE $84 ; two lines for E:, interrupt first
        .BYTE 2
        .BYTE 2
        .BYTE $41
        .WORD STARTDL
; and now the interrupt
DLI     PHA ; always save the accumulator!
        LDA #$CA
        STA $D017 ; COLPF1 hardware register
        LDA #$94
        STA $D018 ; COLPF2 hardware register
        LDA #$E0 ; Atari ROM character set
        STA $D409 ; CHBASE hardware register; shadow is $2F4 CHBAS
        PLA
        RTI
;
; Map of what internal char code goes with which hex digit
HEXMAP  .BYTE $10,$11,$12,$13, $14,$15,$16,$17
        .BYTE $18,$19,$21,$22, $23,$24,$25,$26

; Player Definitions
        *=  STARTPM+$200   ; START OF PLAYER 0
        *=  STARTPM+$200+16
        @B4 $60 ; PLAYER 0 ROW  0
        @B4__00 ; PLAYER 0 ROW  1
        @B4__00 ; PLAYER 0 ROW  2
        @B4__00 ; PLAYER 0 ROW  3
        @B4__00 ; PLAYER 0 ROW  4
        @B4__00 ; PLAYER 0 ROW  5
        @B4__00 ; PLAYER 0 ROW  6
        @B4__00 ; PLAYER 0 ROW  7
        @B4__00 ; PLAYER 0 ROW  8
        @B4 $60 ; PLAYER 0 ROW  9
        @B4__00 ; PLAYER 0 ROW 10
        @B4 $60 ; PLAYER 0 ROW 11
        @B4__00 ; PLAYER 0 ROW 12
        @B4 $60 ; PLAYER 0 ROW 13
        @B4 $60 ; PLAYER 0 ROW 14
        @B4__00 ; PLAYER 0 ROW 15
        @B4 $60 ; PLAYER 0 ROW 16
        @B4__00 ; PLAYER 0 ROW 17
        @B4__00 ; PLAYER 0 ROW 18
        @B4__00 ; PLAYER 0 ROW 19
        @B4__00 ; PLAYER 0 ROW 20
        @B4__00 ; PLAYER 0 ROW 21
        @B4__00 ; PLAYER 0 ROW 22
        @B4__00 ; PLAYER 0 ROW 23
        *=  STARTPM+$280   ; START OF PLAYER 1
        *=  STARTPM+$280+16
        @B4 $00 ; PLAYER 1 ROW  0
        @B4 $60 ; PLAYER 1 ROW  1
        @B4 $00 ; PLAYER 1 ROW  2
        @B4 $00 ; PLAYER 1 ROW  3
        @B4 $00 ; PLAYER 1 ROW  4
        @B4 $00 ; PLAYER 1 ROW  5
        @B4 $00 ; PLAYER 1 ROW  6
        @B4 $00 ; PLAYER 1 ROW  7
        @B4 $00 ; PLAYER 1 ROW  8
        @B4 $50 ; PLAYER 1 ROW  9
        @B4 $00 ; PLAYER 1 ROW 10
        @B4 $00 ; PLAYER 1 ROW 11
        @B4 $60 ; PLAYER 1 ROW 12
        @B4 $50 ; PLAYER 1 ROW 13
        @B4 $00 ; PLAYER 1 ROW 14
        @B4 $60 ; PLAYER 1 ROW 15
        @B4 $50 ; PLAYER 1 ROW 16
        @B4__00 ; PLAYER 1 ROW 17
        @B4__00 ; PLAYER 1 ROW 18
        @B4__00 ; PLAYER 1 ROW 19
        @B4__00 ; PLAYER 1 ROW 20
        @B4__00 ; PLAYER 1 ROW 21
        @B4__00 ; PLAYER 1 ROW 22
        @B4__00 ; PLAYER 1 ROW 23
        *=  STARTPM+$300  ; START OF PLAYER 2
        *=  STARTPM+$300+16
        @B4 $00 ; PLAYER 2 ROW  0
        @B4 $00 ; PLAYER 2 ROW  1
        @B4 $60 ; PLAYER 2 ROW  2
        @B4 $00 ; PLAYER 2 ROW  3
        @B4 $00 ; PLAYER 2 ROW  4
        @B4 $00 ; PLAYER 2 ROW  5
        @B4 $00 ; PLAYER 2 ROW  6
        @B4 $00 ; PLAYER 2 ROW  7
        @B4 $00 ; PLAYER 2 ROW  8
        @B4 $00 ; PLAYER 2 ROW  9
        @B4 $60 ; PLAYER 2 ROW 10
        @B4__00 ; PLAYER 2 ROW 11
        @B4__00 ; PLAYER 2 ROW 12
        @B4__00 ; PLAYER 2 ROW 13
        @B4__00 ; PLAYER 2 ROW 14
        @B4__00 ; PLAYER 2 ROW 15
        @B4__00 ; PLAYER 2 ROW 16
        @B4__00 ; PLAYER 2 ROW 17
        @B4__00 ; PLAYER 2 ROW 18
        @B4__00 ; PLAYER 2 ROW 19
        @B4__00 ; PLAYER 2 ROW 20
        @B4__00 ; PLAYER 2 ROW 21
        @B4__00 ; PLAYER 2 ROW 22
        @B4__00 ; PLAYER 2 ROW 23
        *=  STARTPM+$380   ; START OF PLAYER 3
        *=  STARTPM+$380+16
        @B4 $00 ; PLAYER 3 ROW  0
        @B4 $00 ; PLAYER 3 ROW  1
        @B4 $00 ; PLAYER 3 ROW  2
        @B4 $60 ; PLAYER 3 ROW  3
        @B4 $00 ; PLAYER 3 ROW  4
        @B4 $00 ; PLAYER 3 ROW  5
        @B4 $00 ; PLAYER 3 ROW  6
        @B4 $00 ; PLAYER 3 ROW  7
        @B4 $00 ; PLAYER 3 ROW  8
        @B4 $00 ; PLAYER 3 ROW  9
        @B4 $50 ; PLAYER 3 ROW 10
        @B4__00 ; PLAYER 3 ROW 11
        @B4__00 ; PLAYER 3 ROW 12
        @B4__00 ; PLAYER 3 ROW 13
        @B4__00 ; PLAYER 3 ROW 14
        @B4__00 ; PLAYER 3 ROW 15
        @B4__00 ; PLAYER 3 ROW 16
        @B4__00 ; PLAYER 3 ROW 17
        @B4__00 ; PLAYER 3 ROW 18
        @B4__00 ; PLAYER 3 ROW 19
        @B4__00 ; PLAYER 3 ROW 20
        @B4__00 ; PLAYER 3 ROW 21
        @B4__00 ; PLAYER 3 ROW 22
        @B4__00 ; PLAYER 3 ROW 23

        .PAGE       Cartridge Trailer
        .IF TARGET = 2 .OR TARGET = 4 .OR TARGET = 8 ; any size cartridge
        .IF DEBUGMODE = 1
        *=  CARTINI - 32
        .BYTE 0,0,0,"Cartridge Header",0,0,0
        .ENDIF
        *=  CARTINI
        ; Cart init code goes here -- usually nothing at all!
        RTS ; end of cart initialization
        .WORD STARTUP ; where to JMP after cart and OS are initted
        .BYTE 0     ; just a zero
        .BYTE 4     ; boot opt - no disk
        .WORD CARTINI
        .ENDIF
        .END
